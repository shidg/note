# 设置当前上下文中所有后续 kubectl 命令使用的命名空间
kubectl config set-context --current --namespace=<insert-namespace-name-here>


# 根据label标签过滤查询结果
kubectl get pods -l environment=production,tier=frontend
kubectl get pods -l 'environment in (production),tier in (frontend)'
kubectl get pods -l 'environment in (production, qa)'
kubectl get pods -l 'environment,environment notin (frontend)'

# field-selector
kubectl get pods --field-selector status.phase=Running
kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always

# 设置节点为不可调度
kubectl cordon nodename
# 去除不可调度
kubectl uncordon nodename

# 驱逐节点上的pod
kubectl drain nodename --delete-local-data --ignore-daemonsets --force

# --delete-local-data 即使pod使用了emptyDir也删除
# --ignore-daemonsets 忽略deamonset控制器的pod，如果不忽略，deamonset控制器控制的pod被删除后可能马上又在此节点上启动起来,会成为死循环；
# --force 不加force参数只会删除该NODE上由ReplicationController, ReplicaSet, DaemonSet,StatefulSet or
# Job创建的Pod，加了后还会删除'裸奔的pod'(没有绑定到任何replication controller)


# 增加节点

# master上
# kubeadm token create --print-join-command

# node上
# kubeadm reset


# 回滚
kubectl rollout history deployment ${deployment_name}
kubectl rollout undo deployment ${deployment_name} --to-revision=1
